<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>YeYing Wallet - å®Œæ•´æµ‹è¯•</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 800px;
        margin: 0 auto;
        background: white;
        border-radius: 16px;
        padding: 30px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      }

      h1 {
        color: #333;
        margin-bottom: 10px;
      }

      .status {
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        font-size: 14px;
      }

      .status.connected {
        background: #e8f5e9;
        color: #2e7d32;
        border: 1px solid #4caf50;
      }

      .status.disconnected {
        background: #ffebee;
        color: #c62828;
        border: 1px solid #f44336;
      }

      .section {
        margin-bottom: 30px;
        padding: 20px;
        background: #f5f5f5;
        border-radius: 8px;
      }

      .section h2 {
        font-size: 18px;
        margin-bottom: 15px;
        color: #555;
      }

      .button-group {
        display: flex;
        gap: 10px;
        flex-wrap: wrap;
      }

      button {
        padding: 12px 24px;
        border: none;
        border-radius: 8px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s;
      }

      button:hover {
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
      }

      .btn-primary {
        background: #667eea;
        color: white;
      }

      .btn-secondary {
        background: #48bb78;
        color: white;
      }

      .btn-danger {
        background: #f56565;
        color: white;
      }

      .btn-info {
        background: #4299e1;
        color: white;
      }

      .info-box {
        background: white;
        padding: 15px;
        border-radius: 8px;
        margin-top: 15px;
        font-family: "Courier New", monospace;
        font-size: 13px;
        word-break: break-all;
      }

      .info-box strong {
        color: #667eea;
      }

      .log {
        background: #1a202c;
        color: #68d391;
        padding: 15px;
        border-radius: 8px;
        max-height: 300px;
        overflow-y: auto;
        font-family: "Courier New", monospace;
        font-size: 12px;
        margin-top: 20px;
      }

      .log-entry {
        margin-bottom: 5px;
        padding: 5px;
        border-left: 3px solid #667eea;
        padding-left: 10px;
      }

      .log-entry.error {
        border-left-color: #f56565;
        color: #fc8181;
      }

      .log-entry.success {
        border-left-color: #48bb78;
        color: #68d391;
      }
    </style>
  </head>

  <body>
    <div class="container">
      <h1>ğŸ¦… YeYing Wallet - EIP-1193 å®Œæ•´æµ‹è¯•</h1>

      <div id="status" class="status disconnected">æœªè¿æ¥</div>

      <div class="info-box" id="accountInfo" style="display: none">
        <strong>è´¦æˆ·:</strong> <span id="account">-</span><br />
        <strong>é“¾ ID:</strong> <span id="chainId">-</span><br />
        <strong>ä½™é¢:</strong> <span id="balance">-</span><br />
        <strong>è¿æ¥çŠ¶æ€:</strong> <span id="isConnected">-</span>
      </div>

      <!-- 1. è¿æ¥æµ‹è¯• -->
      <div class="section">
        <h2>1ï¸âƒ£ è¿æ¥ä¸è´¦æˆ·</h2>
        <div class="button-group">
          <button class="btn-primary" onclick="testConnect()">è¿æ¥é’±åŒ…</button>
          <button class="btn-secondary" onclick="testGetAccounts()">
            è·å–è´¦æˆ·
          </button>
          <button class="btn-info" onclick="testIsConnected()">
            æ£€æŸ¥è¿æ¥çŠ¶æ€
          </button>
          <button class="btn-danger" onclick="testDisconnect()">
            æ–­å¼€è¿æ¥
          </button>
        </div>
      </div>

      <!-- 2. ç½‘ç»œæµ‹è¯• -->
      <div class="section">
        <h2>2ï¸âƒ£ ç½‘ç»œç®¡ç†</h2>
        <div class="button-group">
          <button class="btn-primary" onclick="testGetChainId()">
            è·å–é“¾ ID
          </button>
          <button class="btn-secondary" onclick="testSwitchToSepolia()">
            åˆ‡æ¢åˆ° Sepolia
          </button>
          <button class="btn-secondary" onclick="testSwitchToMainnet()">
            åˆ‡æ¢åˆ°ä¸»ç½‘
          </button>
          <button class="btn-info" onclick="testAddPolygon()">
            æ·»åŠ  Polygon
          </button>
          <button class="btn-info" onclick="testAddBSC()">æ·»åŠ  BSC</button>
        </div>
      </div>

      <!-- 3. äº¤æ˜“æµ‹è¯• -->
      <div class="section">
        <h2>3ï¸âƒ£ äº¤æ˜“</h2>
        <div class="button-group">
          <button class="btn-primary" onclick="testSendTransaction()">
            å‘é€ 0.001 ETH
          </button>
          <button class="btn-secondary" onclick="testSendWithData()">
            å‘é€å¸¦æ•°æ®çš„äº¤æ˜“
          </button>
        </div>
      </div>

      <!-- 4. ç­¾åæµ‹è¯• -->
      <div class="section">
        <h2>4ï¸âƒ£ ç­¾å</h2>
        <div class="button-group">
          <button class="btn-primary" onclick="testPersonalSign()">
            ä¸ªäººç­¾å
          </button>
          <button class="btn-secondary" onclick="testSignTypedData()">
            TypedData ç­¾å
          </button>
        </div>
      </div>

      <!-- 5. ä»£å¸æµ‹è¯• -->
      <div class="section">
        <h2>5ï¸âƒ£ ä»£å¸ç®¡ç†</h2>
        <div class="button-group">
          <button class="btn-primary" onclick="testWatchUSDC()">
            æ·»åŠ  USDC
          </button>
          <button class="btn-secondary" onclick="testWatchDAI()">
            æ·»åŠ  DAI
          </button>
        </div>
      </div>

      <!-- 6. æƒé™æµ‹è¯• -->
      <div class="section">
        <h2>6ï¸âƒ£ æƒé™ç®¡ç†</h2>
        <div class="button-group">
          <button class="btn-primary" onclick="testGetPermissions()">
            è·å–æƒé™
          </button>
          <button class="btn-secondary" onclick="testRequestPermissions()">
            è¯·æ±‚æƒé™
          </button>
          <button class="btn-danger" onclick="testRevokePermissions()">
            æ’¤é”€æƒé™
          </button>
        </div>
      </div>

      <!-- 7. äº‹ä»¶æµ‹è¯• -->
      <div class="section">
        <h2>7ï¸âƒ£ äº‹ä»¶ç›‘å¬</h2>
        <div class="button-group">
          <button class="btn-primary" onclick="testListenEvents()">
            å¼€å§‹ç›‘å¬äº‹ä»¶
          </button>
          <button class="btn-danger" onclick="testRemoveListeners()">
            ç§»é™¤ç›‘å¬
          </button>
        </div>
      </div>

      <!-- æ—¥å¿— -->
      <div class="log" id="log">
        <div class="log-entry">ğŸ“‹ æµ‹è¯•æ—¥å¿—å°†æ˜¾ç¤ºåœ¨è¿™é‡Œ...</div>
      </div>
    </div>

    <script>
      let ethereum = null;
      let providerPromise = null;
      let currentAccount = null;
      let eventListeners = {};

      function waitForEthereum(timeout = 3000) {
        if (window.ethereum) {
          ethereum = window.ethereum;
          return Promise.resolve(ethereum);
        }

        if (!providerPromise) {
          providerPromise = new Promise((resolve, reject) => {
            const timer = setTimeout(() => {
              reject(new Error("æœªæ£€æµ‹åˆ°é’±åŒ… Provider"));
            }, timeout);

            const handler = () => {
              if (window.ethereum) {
                ethereum = window.ethereum;
                clearTimeout(timer);
                resolve(ethereum);
              }
            };

            window.addEventListener("ethereum#initialized", handler, { once: true });
          });
        }

        return providerPromise;
      }

      // æ—¥å¿—å‡½æ•°
      function log(message, type = "info") {
        const logDiv = document.getElementById("log");
        const entry = document.createElement("div");
        entry.className = `log-entry ${type}`;
        entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
        logDiv.appendChild(entry);
        logDiv.scrollTop = logDiv.scrollHeight;
        console.log(message);
      }

      // æ›´æ–°çŠ¶æ€æ˜¾ç¤º
      function updateStatus(connected, account = null, chainId = null) {
        const statusDiv = document.getElementById("status");
        const accountInfo = document.getElementById("accountInfo");

        if (connected && account) {
          statusDiv.className = "status connected";
          statusDiv.textContent = `âœ… å·²è¿æ¥: ${account.substring(
            0,
            6
          )}...${account.substring(38)}`;
          accountInfo.style.display = "block";
          document.getElementById("account").textContent = account;
          document.getElementById("chainId").textContent = chainId || "-";
          document.getElementById("isConnected").textContent =
            ethereum && ethereum.isConnected() ? "âœ… æ˜¯" : "âŒ å¦";
          currentAccount = account;
          updateBalance(account);
        } else {
          statusDiv.className = "status disconnected";
          statusDiv.textContent = "âŒ æœªè¿æ¥";
          accountInfo.style.display = "none";
          currentAccount = null;
        }
      }

      // æ›´æ–°ä½™é¢
      async function updateBalance(account) {
        try {
          const provider = await waitForEthereum();
          const balance = await provider.request({
            method: "eth_getBalance",
            params: [account, "latest"],
          });
          const ethBalance = parseInt(balance, 16) / 1e18;
          document.getElementById("balance").textContent =
            ethBalance.toFixed(4) + " ETH";
        } catch (error) {
          document.getElementById("balance").textContent = "è·å–å¤±è´¥";
        }
      }

      // ========== 1. è¿æ¥æµ‹è¯• ==========
      async function testConnect() {
        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ è¯·æ±‚è¿æ¥é’±åŒ…...");
          const accounts = await provider.request({
            method: "eth_requestAccounts",
          });
          const chainId = await provider.request({ method: "eth_chainId" });
          log(`âœ… è¿æ¥æˆåŠŸ! è´¦æˆ·: ${accounts[0]}`, "success");
          updateStatus(true, accounts[0], chainId);
        } catch (error) {
          log(`âŒ è¿æ¥å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function testGetAccounts() {
        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ è·å–è´¦æˆ·åˆ—è¡¨...");
          const accounts = await provider.request({ method: "eth_accounts" });
          if (accounts.length > 0) {
            log(`âœ… è´¦æˆ·: ${accounts[0]}`, "success");
            const chainId = await provider.request({ method: "eth_chainId" });
            updateStatus(true, accounts[0], chainId);
          } else {
            log("âš ï¸ æœªæˆæƒï¼Œè¯·å…ˆè¿æ¥é’±åŒ…");
          }
        } catch (error) {
          log(`âŒ è·å–è´¦æˆ·å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function testIsConnected() {
        try {
          const provider = await waitForEthereum();
          const connected = provider.isConnected();
          log(`ğŸ”µ è¿æ¥çŠ¶æ€: ${connected ? "âœ… å·²è¿æ¥" : "âŒ æœªè¿æ¥"}`);
        } catch (error) {
          log(`âŒ æ£€æµ‹å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function testDisconnect() {
        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ æ’¤é”€æƒé™...");
          await provider.request({
            method: "wallet_revokePermissions",
            params: [{ eth_accounts: {} }],
          });
          log("âœ… å·²æ–­å¼€è¿æ¥", "success");
          updateStatus(false);
        } catch (error) {
          log(`âŒ æ–­å¼€å¤±è´¥: ${error.message}`, "error");
        }
      }

      // ========== 2. ç½‘ç»œæµ‹è¯• ==========
      async function testGetChainId() {
        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ è·å–é“¾ ID...");
          const chainId = await provider.request({ method: "eth_chainId" });
          log(`âœ… å½“å‰é“¾ ID: ${chainId} (${parseInt(chainId, 16)})`, "success");
        } catch (error) {
          log(`âŒ è·å–å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function testSwitchToSepolia() {
        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ åˆ‡æ¢åˆ° Sepolia æµ‹è¯•ç½‘...");
          await provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: "0xaa36a7" }],
          });
          log("âœ… åˆ‡æ¢æˆåŠŸ!", "success");
        } catch (error) {
          log(`âŒ åˆ‡æ¢å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function testSwitchToMainnet() {
        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ åˆ‡æ¢åˆ°ä»¥å¤ªåŠä¸»ç½‘...");
          await provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: "0x1" }],
          });
          log("âœ… åˆ‡æ¢æˆåŠŸ!", "success");
        } catch (error) {
          log(`âŒ åˆ‡æ¢å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function testAddPolygon() {
        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ æ·»åŠ  Polygon ç½‘ç»œ...");
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [
              {
                chainId: "0x89",
                chainName: "Polygon Mainnet",
                rpcUrls: ["https://polygon-rpc.com"],
                nativeCurrency: {
                  name: "MATIC",
                  symbol: "MATIC",
                  decimals: 18,
                },
                blockExplorerUrls: ["https://polygonscan.com"],
              },
            ],
          });
          log("âœ… Polygon ç½‘ç»œæ·»åŠ æˆåŠŸ!", "success");
        } catch (error) {
          log(`âŒ æ·»åŠ å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function testAddBSC() {
        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ æ·»åŠ  BSC ç½‘ç»œ...");
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [
              {
                chainId: "0x38",
                chainName: "BNB Smart Chain",
                rpcUrls: ["https://bsc-dataseed.binance.org"],
                nativeCurrency: {
                  name: "BNB",
                  symbol: "BNB",
                  decimals: 18,
                },
                blockExplorerUrls: ["https://bscscan.com"],
              },
            ],
          });
          log("âœ… BSC ç½‘ç»œæ·»åŠ æˆåŠŸ!", "success");
        } catch (error) {
          log(`âŒ æ·»åŠ å¤±è´¥: ${error.message}`, "error");
        }
      }

      // ========== 3. äº¤æ˜“æµ‹è¯• ==========
      async function testSendTransaction() {
        if (!currentAccount) {
          log("âš ï¸ è¯·å…ˆè¿æ¥é’±åŒ…");
          return;
        }

        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ å‘é€ 0.001 ETH...");
          const txHash = await provider.request({
            method: "eth_sendTransaction",
            params: [
              {
                from: currentAccount,
                to: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
                value: "0x38D7EA4C68000", // 0.001 ETH
                gas: "0x5208",
              },
            ],
          });
          log(`âœ… äº¤æ˜“å·²å‘é€! Hash: ${txHash}`, "success");
        } catch (error) {
          log(`âŒ äº¤æ˜“å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function testSendWithData() {
        if (!currentAccount) {
          log("âš ï¸ è¯·å…ˆè¿æ¥é’±åŒ…");
          return;
        }

        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ å‘é€å¸¦æ•°æ®çš„äº¤æ˜“...");
          const txHash = await provider.request({
            method: "eth_sendTransaction",
            params: [
              {
                from: currentAccount,
                to: "0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb",
                value: "0x0",
                data: "0x48656c6c6f20576f726c6421", // "Hello World!"
              },
            ],
          });
          log(`âœ… äº¤æ˜“å·²å‘é€! Hash: ${txHash}`, "success");
        } catch (error) {
          log(`âŒ äº¤æ˜“å¤±è´¥: ${error.message}`, "error");
        }
      }

      // ========== 4. ç­¾åæµ‹è¯• ==========
      async function testPersonalSign() {
        if (!currentAccount) {
          log("âš ï¸ è¯·å…ˆè¿æ¥é’±åŒ…");
          return;
        }

        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ è¯·æ±‚ä¸ªäººç­¾å...");
          const message = "Hello from YeYing Wallet Test!";
          const signature = await provider.request({
            method: "personal_sign",
            params: [message, currentAccount],
          });
          log(
            `âœ… ç­¾åæˆåŠŸ! Signature: ${signature.substring(0, 20)}...`,
            "success"
          );
        } catch (error) {
          log(`âŒ ç­¾åå¤±è´¥: ${error.message}`, "error");
        }
      }

      async function testSignTypedData() {
        if (!currentAccount) {
          log("âš ï¸ è¯·å…ˆè¿æ¥é’±åŒ…");
          return;
        }

        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ è¯·æ±‚ TypedData ç­¾å...");
          const msgParams = {
            domain: {
              chainId: 1,
              name: "Ether Mail",
              verifyingContract: "0xCcCCccccCCCCcCCCCCCcCcCccCcCCCcCcccccccC",
              version: "1",
            },
            message: {
              contents: "Hello, Bob!",
              from: {
                name: "Cow",
                wallet: "0xCD2a3d9F938E13CD947Ec05AbC7FE734Df8DD826",
              },
              to: {
                name: "Bob",
                wallet: "0xbBbBBBBbbBBBbbbBbbBbbbbBBbBbbbbBbBbbBBbB",
              },
            },
            primaryType: "Mail",
            types: {
              EIP712Domain: [
                { name: "name", type: "string" },
                { name: "version", type: "string" },
                { name: "chainId", type: "uint256" },
                { name: "verifyingContract", type: "address" },
              ],
              Mail: [
                { name: "from", type: "Person" },
                { name: "to", type: "Person" },
                { name: "contents", type: "string" },
              ],
              Person: [
                { name: "name", type: "string" },
                { name: "wallet", type: "address" },
              ],
            },
          };

          const signature = await provider.request({
            method: "eth_signTypedData_v4",
            params: [currentAccount, JSON.stringify(msgParams)],
          });
          log(
            `âœ… TypedData ç­¾åæˆåŠŸ! Signature: ${signature.substring(
              0,
              20
            )}...`,
            "success"
          );
        } catch (error) {
          log(`âŒ ç­¾åå¤±è´¥: ${error.message}`, "error");
        }
      }

      // ========== 5. ä»£å¸æµ‹è¯• ==========
      async function testWatchUSDC() {
        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ æ·»åŠ  USDC ä»£å¸...");
          const result = await provider.request({
            method: "wallet_watchAsset",
            params: {
              type: "ERC20",
              options: {
                address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
                symbol: "USDC",
                decimals: 6,
                image: "https://cryptologos.cc/logos/usd-coin-usdc-logo.png",
              },
            },
          });
          log(
            result ? "âœ… USDC æ·»åŠ æˆåŠŸ!" : "âš ï¸ ç”¨æˆ·å–æ¶ˆ",
            result ? "success" : "info"
          );
        } catch (error) {
          log(`âŒ æ·»åŠ å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function testWatchDAI() {
        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ æ·»åŠ  DAI ä»£å¸...");
          const result = await provider.request({
            method: "wallet_watchAsset",
            params: {
              type: "ERC20",
              options: {
                address: "0x6B175474E89094C44Da98b954EedeAC495271d0F",
                symbol: "DAI",
                decimals: 18,
                image:
                  "https://cryptologos.cc/logos/multi-collateral-dai-dai-logo.png",
              },
            },
          });
          log(
            result ? "âœ… DAI æ·»åŠ æˆåŠŸ!" : "âš ï¸ ç”¨æˆ·å–æ¶ˆ",
            result ? "success" : "info"
          );
        } catch (error) {
          log(`âŒ æ·»åŠ å¤±è´¥: ${error.message}`, "error");
        }
      }

      // ========== 6. æƒé™æµ‹è¯• ==========
      async function testGetPermissions() {
        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ è·å–æƒé™åˆ—è¡¨...");
          const permissions = await provider.request({
            method: "wallet_getPermissions",
          });
          log(`âœ… æƒé™: ${JSON.stringify(permissions, null, 2)}`, "success");
        } catch (error) {
          log(`âŒ è·å–å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function testRequestPermissions() {
        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ è¯·æ±‚æƒé™...");
          const permissions = await provider.request({
            method: "wallet_requestPermissions",
            params: [{ eth_accounts: {} }],
          });
          log(
            `âœ… æƒé™å·²æˆäºˆ: ${JSON.stringify(permissions, null, 2)}`,
            "success"
          );
        } catch (error) {
          log(`âŒ è¯·æ±‚å¤±è´¥: ${error.message}`, "error");
        }
      }

      async function testRevokePermissions() {
        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ æ’¤é”€æƒé™...");
          await provider.request({
            method: "wallet_revokePermissions",
            params: [{ eth_accounts: {} }],
          });
          log("âœ… æƒé™å·²æ’¤é”€", "success");
          updateStatus(false);
        } catch (error) {
          log(`âŒ æ’¤é”€å¤±è´¥: ${error.message}`, "error");
        }
      }

      // ========== 7. äº‹ä»¶æµ‹è¯• ==========
      async function testListenEvents() {
        try {
          const provider = await waitForEthereum();
          log("ğŸ”µ å¼€å§‹ç›‘å¬äº‹ä»¶...");

          // connect äº‹ä»¶
          eventListeners.connect = (connectInfo) => {
            log(`ğŸ“¢ connect äº‹ä»¶: chainId=${connectInfo.chainId}`, "success");
          };
          provider.on("connect", eventListeners.connect);

          // disconnect äº‹ä»¶
          eventListeners.disconnect = (error) => {
            log(`ğŸ“¢ disconnect äº‹ä»¶: ${error.message}`, "error");
            updateStatus(false);
          };
          provider.on("disconnect", eventListeners.disconnect);

          // accountsChanged äº‹ä»¶
          eventListeners.accountsChanged = (accounts) => {
            log(`ğŸ“¢ accountsChanged äº‹ä»¶: ${accounts[0] || "æ— è´¦æˆ·"}`, "success");
            if (accounts.length > 0) {
              provider.request({ method: "eth_chainId" }).then((chainId) => {
                updateStatus(true, accounts[0], chainId);
              });
            } else {
              updateStatus(false);
            }
          };
          provider.on("accountsChanged", eventListeners.accountsChanged);

          // chainChanged äº‹ä»¶
          eventListeners.chainChanged = (chainId) => {
            log(
              `ğŸ“¢ chainChanged äº‹ä»¶: ${chainId} (${parseInt(chainId, 16)})`,
              "success"
            );
            if (currentAccount) {
              updateStatus(true, currentAccount, chainId);
            }
          };
          provider.on("chainChanged", eventListeners.chainChanged);

          log("âœ… äº‹ä»¶ç›‘å¬å·²å¯åŠ¨", "success");
        } catch (error) {
          log(`âŒ ç›‘å¬å¤±è´¥: ${error.message}`, "error");
        }
      }

      function testRemoveListeners() {
        log("ğŸ”µ ç§»é™¤äº‹ä»¶ç›‘å¬...");

        if (ethereum) {
          if (eventListeners.connect) {
            ethereum.removeListener("connect", eventListeners.connect);
          }
          if (eventListeners.disconnect) {
            ethereum.removeListener("disconnect", eventListeners.disconnect);
          }
          if (eventListeners.accountsChanged) {
            ethereum.removeListener(
              "accountsChanged",
              eventListeners.accountsChanged
            );
          }
          if (eventListeners.chainChanged) {
            ethereum.removeListener("chainChanged", eventListeners.chainChanged);
          }
        }

        eventListeners = {};
        log("âœ… äº‹ä»¶ç›‘å¬å·²ç§»é™¤", "success");
      }

      // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨æ£€æŸ¥è¿æ¥çŠ¶æ€
      window.addEventListener("load", async () => {
        try {
          await waitForEthereum();
          log("âœ… YeYing Wallet å·²æ£€æµ‹åˆ°", "success");
          await testListenEvents();

          try {
            const accounts = await ethereum.request({ method: "eth_accounts" });
            if (accounts.length > 0) {
              const chainId = await ethereum.request({ method: "eth_chainId" });
              updateStatus(true, accounts[0], chainId);
              log("âœ… è‡ªåŠ¨æ¢å¤è¿æ¥çŠ¶æ€", "success");
            }
          } catch (error) {
            log("âš ï¸ æ— æ³•æ¢å¤è¿æ¥çŠ¶æ€");
          }
        } catch (error) {
          log("âŒ æœªæ£€æµ‹åˆ° YeYing Wallet", "error");
          ethereum = undefined;
        }
      });
    </script>
  </body>
</html>
